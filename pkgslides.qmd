% Generated by pkgslides: do not edit by hand
---
title: pkgslides
subtitle: 0.1.0
format:
  revealjs:
    theme: default
    navigation-mode: vertical
    self-contained: true
    scrollable: true
---

## Automatically Generate Presentations for Source Code

::: {.r-fit-text}

When pointed at the root directory of an R Package Project, this 
  function will automatically generate and render a Quarto/Revealjs 
  presentation for that package. It will have a title slide and description 
  slide generated from the package's DESCRIPTION file and each exported 
  function will have slides with its description and returns, parameters, 
  examples, and source code.

:::

```{r}
#| echo: false
library(pkgslides)
```

# Create a Revealjs Presentation with Quarto

::: {.r-fit-text}

- **Topic:** `build_presentation`

- **Description:** When pointed at the root directory of an R Package Project, this
function will automatically generate and render a Quarto/Revealjs
presentation for that package. It will have a title slide and description
slide generated from the package's DESCRIPTION file and each exported
function will have slides with its description and returns, parameters,
examples, and source code.

- **Return:** This function creates and renders a .qmd presentation but does not
return an R object.

:::


## Parameters

::: {.r-fit-text}

- `package`: A file path to the root directory of an R package source
folder.
- `file`: The file name for your .qmd file. This can be a path so long as
it ends with a `file_name.qmd`
- `yaml`: A `_pkgslides.yml` file or function call to `create_yaml()`

:::


## `build_presentation.R`

::: {.r-fit-text}

```{.r}
build_presentation <- function(package = NULL, file = NULL, yaml = create_yaml()) {
    package <- .find_package(package)
    file <- .find_file(package, file)
    yaml <- .parse_yaml(yaml)
    if (rev(strsplit(package, "/")[[1]])[1] %in% rownames(utils::installed.packages())) {
        chunk_opt <- "echo"
    }
    else {
        chunk_opt <- "eval"
    }
    title_contents <- .collate_title(.get_title(package), yaml)
    package_contents <- .collate_description(.get_description(package), 
        chunk_opt)
    contents <- .get_roxygen(package, yaml)
    r_files <- paste0(package, "/R")
    package_functions <- list.files(r_files, pattern = "\\.R$")
    function_contents <- unlist(lapply(.get_functions(contents$functions, 
        yaml), .collate_functions, chunk_opt))
    data_contents <- unlist(lapply(.get_datasets(contents$datasets, 
        yaml), .collate_datasets))
    file_contents <- c(title_contents, package_contents, function_contents, 
        data_contents)
    print(file)
    file.create(file)
    fileConn <- file(file)
    writeLines(file_contents, fileConn)
    close(fileConn)
    quarto::quarto_render(file)
}
```

:::

# `.find_file`

::: {.r-fit-text}

- **Topic:** `.find_file`

- **Return:** A file path to write the .qmd to

:::


## Parameters

::: {.r-fit-text}

- `package`: A path to a package source
- `file`: A file path

:::


## `build_presentation.R`

::: {.r-fit-text}

```{.r}
.find_file <- function(package, file) {
    if (is.null(file)) {
        file <- .get_file_from_path(package)
    }
    if (!grepl("\\.qmd$", file)) {
        file <- paste0(file, ".qmd")
    }
    file <- glue::glue("{getwd()}/{file}")
    return(file)
}
```

:::

# `.find_package`

::: {.r-fit-text}

- **Topic:** `.find_package`

- **Return:** A path to a package source

:::


## Parameters

::: {.r-fit-text}

- `package`: A package name or file path to a package source

:::


## `build_presentation.R`

::: {.r-fit-text}

```{.r}
.find_package <- function(package) {
    if (is.null(package)) {
        package <- getwd()
        return(package)
    }
    else if (dir.exists(package)) {
        return(package)
    }
    source_path <- tempdir()
    utils::download.packages(package, source_path)
    source_name <- list.files(source_path, pattern = glue::glue("{package}.*\\.tar\\.gz"))
    utils::untar(glue::glue("{source_path}/{source_name}"), exdir = glue::glue("{source_path}"))
    package <- glue::glue("{source_path}/{package}")
    return(package)
}
```

:::

# Create `_pkgslides.yml`

::: {.r-fit-text}

- **Topic:** `create_yaml`

- **Return:** This will not fill the file, simply create it.

:::


## Parameters

::: {.r-fit-text}

- `path`: A file path to where you want the yaml file written. This should
not end in a slash of any kind.
- `format_theme`: A length-one character vector of theme details
- `format_functions`: A named list of format function options
- `format_datasets`: A named list of format dataset options
- `choose_functions`: A list of file or function names
- `choose_datasets`: A vector of dataset names

:::


## `yaml.R`

::: {.r-fit-text}

```{.r}
create_yaml <- function(path = ".", format_theme = c(), format_functions = list(), 
    format_datasets = list(), choose_functions = list(), choose_datasets = c()) {
    file <- glue::glue("{path}/_pkgslides.yml")
    stopifnot(!file.exists(file))
    format_theme <- format_theme[format_theme %in% c("theme")]
    format_functions <- format_functions[names(format_functions) %in% 
        c("description", "return", "parameters", "examples", 
            "code")]
    format_datasets <- format_datasets[names(format_datasets) %in% 
        c("format", "source", "references")]
    .append_to_yaml <- function(yaml, obj, name) {
        if (length(obj) > 0) {
            yaml$format[[name]] <- obj
        }
        return(yaml)
    }
    yaml <- .append_to_yaml(.append_to_yaml(.append_to_yaml(list(), 
        format_theme, "theme"), format_functions, "functions"), 
        format_datasets, "datasets")
    if (length(choose_functions) > 0) {
        yaml <- .process_choose_functions(yaml, choose_functions)
    }
    yaml$datasets <- choose_datasets
    yaml::write_yaml(.check_yaml(yaml), file)
    print(glue::glue("Config written to '{file}'"))
    return(file)
}
```

:::

# Parse `_pkgslides.yml`

::: {.r-fit-text}

- **Topic:** `.parse_yaml`

- **Return:** A list representing a yaml file

:::


## Parameters

::: {.r-fit-text}

- `file`: A file path the _pkgslides.yml file

:::


## `yaml.R`

::: {.r-fit-text}

```{.r}
.parse_yaml <- function(file) {
    if (file.exists(file)) {
        yaml <- .check_yaml(yaml::read_yaml(file))
    }
    else {
        yaml <- .check_yaml(list())
    }
    return(yaml)
}
```

:::

# Fill an Incomplete `_pkgslides.yml`

::: {.r-fit-text}

- **Topic:** `.check_yaml`

- **Return:** A list representing a yaml file

:::


## Parameters

::: {.r-fit-text}

- `yaml`: A list of properties from `.parse_yaml()`

:::


## `yaml.R`

::: {.r-fit-text}

```{.r}
.check_yaml <- function(yaml) {
    if (is.null(yaml$functions)) {
        yaml$functions <- "auto"
    }
    if (is.null(yaml$datasets)) {
        yaml$datasets <- "all"
    }
    if (is.null(yaml$format$theme)) {
        yaml$format$theme <- "default"
    }
    yaml <- .set_as_true(.set_as_true(yaml, "functions", c("description", 
        "return", "parameters", "examples", "code")), "datasets", 
        c("format", "source", "references"))
    return(yaml)
}
```

:::

# `.set_as_true`

::: {.r-fit-text}

- **Topic:** `.set_as_true`

- **Return:** A yaml where non-included options are set to TRUE

:::


## Parameters

::: {.r-fit-text}

- `yaml`: A yaml file as a list
- `type`: "functions" or "datasets"
- `options`: A vector of the options exposed to users in the yaml format

:::


## `yaml.R`

::: {.r-fit-text}

```{.r}
.set_as_true <- function(yaml, type, options) {
    requested <- names(yaml$format[[type]])
    not_specified <- options[!(options %in% requested)]
    yaml$format[[type]] <- append(`names<-`(lapply(seq_along(not_specified), 
        function(s) TRUE), not_specified), yaml$format[[type]])
    return(yaml)
}
```

:::

# `.process_choose_functions`

::: {.r-fit-text}

- **Topic:** `.process_choose_functions`

- **Return:** A list representing a yaml file

:::


## Parameters

::: {.r-fit-text}

- `yaml`: A list representing a yaml file
- `choose`: The list passed to `choose_functions` in the `create_yaml`
function

:::


## `yaml.R`

::: {.r-fit-text}

```{.r}
.process_choose_functions <- function(yaml, choose) {
    yaml2 <- list()
    dim <- vapply(choose, length, FUN.VALUE = 1)
    choose_names <- names(choose)
    opt_regex <- "^(auto|exported|all)$|\\.R$"
    if (all(dim == 1) & is.null(choose_names)) {
        stopifnot(all(grepl(opt_regex, choose)))
        yaml2$functions <- lapply(choose, function(x) {
            list(file = x)
        })
    }
    else {
        if (any(choose_names == "")) {
            needs_name <- which(choose_names == "" & dim == 1)
            names(choose)[needs_name] <- unlist(sapply(choose, 
                unlist)[needs_name])
            choose[needs_name] <- "all"
            choose_names <- names(choose)
        }
        stopifnot(all(grepl(opt_regex, choose_names)))
        yaml2$functions <- mapply(function(x, y) {
            list(file = x, slides = y)
        }, choose_names, choose, SIMPLIFY = FALSE, USE.NAMES = FALSE)
    }
    yaml <- unlist(list(yaml, yaml2), recursive = FALSE)
    return(yaml)
}
```

:::
